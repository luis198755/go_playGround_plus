{
  "hello-world": {
    "name": "Hello, World!",
    "code": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, 世界\")\n}"
  },
  "fibonacci-closure": {
    "name": "Fibonacci Closure",
    "code": "package main\n\nimport \"fmt\"\n\n// fibonacci is a function that returns\n// a function that returns an int.\nfunc fibonacci() func() int {\n    first, second := 0, 1\n    return func() int {\n        ret := first\n        first, second = second, first+second\n        return ret\n    }\n}\n\nfunc main() {\n    f := fibonacci()\n    for i := 0; i < 10; i++ {\n        fmt.Printf(\"%d \", f())\n    }\n}"
  },
  "goroutines": {
    "name": "Goroutines",
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc say(s string) {\n    for i := 0; i < 5; i++ {\n        time.Sleep(100 * time.Millisecond)\n        fmt.Println(s)\n    }\n}\n\nfunc main() {\n    go say(\"world\")\n    say(\"hello\")\n}"
  },
  "channels": {
    "name": "Channels",
    "code": "package main\n\nimport \"fmt\"\n\nfunc sum(s []int, c chan int) {\n    sum := 0\n    for _, v := range s {\n        sum += v\n    }\n    c <- sum // send sum to c\n}\n\nfunc main() {\n    s := []int{7, 2, 8, -9, 4, 0}\n    c := make(chan int)\n    \n    go sum(s[:len(s)/2], c)\n    go sum(s[len(s)/2:], c)\n    \n    x, y := <-c, <-c // receive from c\n    fmt.Println(x, y, x+y)\n}"
  },
  "goroutines-channels_0": {
    "name": "goroutines-Channels",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// fetchURL realiza una solicitud HTTP GET y envía la respuesta al canal\nfunc fetchURL(url string, ch chan<- string) {\n\tstart := time.Now()\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\tch <- fmt.Sprintf(\"Error al descargar %s: %v\", url, err)\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\n\t// Leer el cuerpo de la respuesta\n\tbody, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\tch <- fmt.Sprintf(\"Error al leer respuesta de %s: %v\", url, err)\n\t\treturn\n\t}\n\n\telapsed := time.Since(start)\n\tch <- fmt.Sprintf(\"Descargado %s (%d bytes) en %v\", url, len(body), elapsed)\n}\n\nfunc main() {\n\t// Lista de URLs a descargar\n\turls := []string{\n\t\t\"https://www.google.com\",\n\t\t\"https://www.github.com\",\n\t\t\"https://www.golang.org\",\n\t}\n\n\t// Crear canal para recibir resultados\n\tch := make(chan string)\n\n\t// Lanzar goroutines para cada URL\n\tfor _, url := range urls {\n\t\tgo fetchURL(url, ch)\n\t}\n\n\t// Recibir y mostrar resultados\n\tfor range urls {\n\t\tfmt.Println(<-ch)\n\t}\n}"
  },
  "goroutines-channels_1": {
    "name": "Números Primos - goroutines-Channels",
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"time\"\n)\n\n// Función para determinar si un número es primo\nfunc isPrime(n int) bool {\n    if n < 2 {\n        return false\n    }\n    for i := 2; i <= int(math.Sqrt(float64(n))); i++ {\n        if n%i == 0 {\n            return false\n        }\n    }\n    return true\n}\n\n// Función que calcula números primos en un rango y envía los resultados a un canal\nfunc findPrimes(start, end int, ch chan<- int) {\n    for i := start; i <= end; i++ {\n        if isPrime(i) {\n            ch <- i // Envía el número primo al canal\n        }\n    }\n    close(ch) // Cierra el canal cuando termina\n}\n\nfunc main() {\n    // Definimos el rango de números a evaluar\n    start := 1\n    end := 100\n\n    // Creamos un canal para recibir los números primos\n    primeChannel := make(chan int)\n\n    // Dividimos el trabajo en dos goroutines\n    mid := (start + end) / 2\n    go findPrimes(start, mid, primeChannel)   // Goroutine 1\n    go findPrimes(mid+1, end, primeChannel) // Goroutine 2\n\n    // Recibimos los resultados del canal y los imprimimos\n    fmt.Println(\"Números primos encontrados:\")\n    timeout := time.After(2 * time.Second) // Timeout para evitar bloqueos infinitos\n    for {\n        select {\n        case prime, ok := <-primeChannel:\n            if !ok {\n                // Si el canal está cerrado, salimos del bucle\n                return\n            }\n            fmt.Println(prime)\n        case <-timeout:\n            fmt.Println(\"Tiempo de espera superado.\")\n            return\n        }\n    }\n}"
  },
  "user-input": {
    "name": "User Input Example",
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"bufio\"\n    \"os\"\n)\n\nfunc main() {\n    reader := bufio.NewReader(os.Stdin)\n    fmt.Print(\"Enter your name: \")\n    name, _ := reader.ReadString('\\n')\n    fmt.Printf(\"Hello, %s\", name)\n}"
  },
  "interfaces": {
    "name": "Interfaces",
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\n// Definimos una interfaz para formas geométricas\ntype Shape interface {\n    Area() float64\n}\n\n// Estructura para un círculo\ntype Circle struct {\n    Radius float64\n}\n\n// Implementación del método Area para Circle\nfunc (c Circle) Area() float64 {\n    return math.Pi * c.Radius * c.Radius\n}\n\n// Estructura para un rectángulo\ntype Rectangle struct {\n    Width, Height float64\n}\n\n// Implementación del método Area para Rectangle\nfunc (r Rectangle) Area() float64 {\n    return r.Width * r.Height\n}\n\n// Función genérica para imprimir el área de cualquier forma\nfunc printArea(s Shape) {\n    fmt.Printf(\"Área: %.2f\\n\", s.Area())\n}\n\nfunc main() {\n    // Creamos un círculo y un rectángulo\n    circle := Circle{Radius: 5}\n    rectangle := Rectangle{Width: 4, Height: 6}\n\n    // Imprimimos las áreas usando la interfaz\n    fmt.Println(\"Círculo:\")\n    printArea(circle)\n\n    fmt.Println(\"Rectángulo:\")\n    printArea(rectangle)\n}"
  },
  "structs_and_methods": {
    "name": "Structs and Methods",
    "code": "package main\n\nimport (\n    \"fmt\"\n)\n\n// Definimos una estructura para representar un libro\ntype Book struct {\n    Title       string\n    Author      string\n    Pages       int\n    WordsPerMin int // Palabras por minuto (velocidad de lectura)\n}\n\n// Método para calcular el tiempo estimado de lectura\nfunc (b Book) EstimatedReadingTime() float64 {\n    words := b.Pages * 250 // Asumimos 250 palabras por página\n    minutes := float64(words) / float64(b.WordsPerMin)\n    return minutes\n}\n\n// Método para imprimir los detalles del libro\nfunc (b Book) PrintDetails() {\n    fmt.Printf(\"Título: %s\\n\", b.Title)\n    fmt.Printf(\"Autor: %s\\n\", b.Author)\n    fmt.Printf(\"Páginas: %d\\n\", b.Pages)\n    fmt.Printf(\"Tiempo estimado de lectura: %.2f minutos\\n\", b.EstimatedReadingTime())\n    fmt.Println()\n}\n\nfunc main() {\n    // Creamos algunos libros\n    book1 := Book{\n        Title:       \"El Quijote\",\n        Author:      \"Miguel de Cervantes\",\n        Pages:       863,\n        WordsPerMin: 200,\n    }\n\n    book2 := Book{\n        Title:       \"Cien años de soledad\",\n        Author:      \"Gabriel García Márquez\",\n        Pages:       417,\n        WordsPerMin: 200,\n    }\n\n    // Imprimimos los detalles de los libros\n    fmt.Println(\"Detalles de los libros:\")\n    book1.PrintDetails()\n    book2.PrintDetails()\n}"
  },
  "file_handling_0": {
    "name": "File Handling",
    "code": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n)\n\nfunc main() {\n    // Nombre de los archivos\n    inputFile := \"./playground_files/input.txt\"\n    outputFile := \"output.txt\"\n\n    // Leer el archivo de entrada\n    lines, err := readFile(inputFile)\n    if err != nil {\n        fmt.Println(\"Error al leer el archivo:\", err)\n        return\n    }\n\n    // Procesar los números y calcular la suma de los pares\n    sum := 0\n    for _, line := range lines {\n        num, err := strconv.Atoi(strings.TrimSpace(line))\n        if err != nil {\n            fmt.Printf(\"Error al convertir '%s' a número: %v\\n\", line, err)\n            continue\n        }\n        if num%2 == 0 { // Verificar si es par\n            sum += num\n        }\n    }\n\n    // Escribir el resultado en el archivo de salida\n    err = writeFile(outputFile, fmt.Sprintf(\"Suma de números pares: %d\", sum))\n    if err != nil {\n        fmt.Println(\"Error al escribir en el archivo:\", err)\n        return\n    }\n\n    fmt.Println(\"Proceso completado. Resultado guardado en\", outputFile)\n}\n\n// Función para leer un archivo y devolver sus líneas\nfunc readFile(filename string) ([]string, error) {\n    file, err := os.Open(filename)\n    if err != nil {\n        return nil, err\n    }\n    defer file.Close()\n\n    var lines []string\n    scanner := bufio.NewScanner(file)\n    for scanner.Scan() {\n        lines = append(lines, scanner.Text())\n    }\n\n    if err := scanner.Err(); err != nil {\n        return nil, err\n    }\n\n    return lines, nil\n}\n\n// Función para escribir en un archivo\nfunc writeFile(filename, content string) error {\n    file, err := os.Create(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    _, err = file.WriteString(content)\n    return err\n}"
  },
  "file_handling_1": {
    "name": "File Handling_1",
    "code": "package main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n)\n\nfunc main() {\n    filePath := \"./playground_files/input.txt\"\n\n    // Leer el contenido del archivo\n    content, err := ioutil.ReadFile(filePath)\n    if err != nil {\n        log.Fatalf(\"Error al leer el archivo: %v\", err)\n    }\n\n    // Mostrar el contenido en la consola\n    fmt.Println(\"Contenido del archivo:\")\n    fmt.Println(string(content))\n}"
  },
  "http_server": {
    "name": "http Server",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc main() {\n\t// Se crea un nuevo mux para registrar las rutas.\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/hello\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprint(w, \"Hello, playground\")\n\t})\n\n\t// Se lanza el servidor en una gorutina.\n\tgo func() {\n\t\tlog.Println(\"Starting server on localhost:8080...\")\n\t\tif err := http.ListenAndServe(\"localhost:8080\", mux); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}()\n\n\t// Pequeño retraso para asegurar que el servidor esté listo.\n\ttime.Sleep(100 * time.Millisecond)\n\n\tlog.Println(\"Sending request...\")\n\tres, err := http.Get(\"http://localhost:8080/hello\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer res.Body.Close()\n\n\tlog.Println(\"Reading response...\")\n\tif _, err := io.Copy(os.Stdout, res.Body); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n"
  },
  "random_sleep_script": {
    "name": "Random Sleep Script",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc main() {\n\tfor i := 0; i < 10; i++ {\n\t\tdur := time.Duration(rand.Intn(1000)) * time.Millisecond\n\t\tfmt.Printf(\"Sleeping for %v\\n\", dur)\n\t\t// Sleep for a random duration between 0-1000ms\n\t\ttime.Sleep(dur)\n\t}\n\tfmt.Println(\"Done!\")\n}\n"
  },
  "complex_go_example": {
    "name": "Complex Go Example",
    "code": "package main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Job represents a background task\ntype Job struct {\n\tID     int           `json:\"id\"`\n\tStatus string        `json:\"status\"`\n\tResult string        `json:\"result\"`\n\tDelay  time.Duration `json:\"delay\"`\n}\n\nvar (\n\tjobQueue   = make(chan *Job, 100)\n\tjobs       = make(map[int]*Job)\n\tjobsMutex  sync.Mutex\n\tjobCounter int\n)\n\n// worker processes jobs from the jobQueue concurrently\nfunc worker(ctx context.Context, id int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfor {\n\t\tselect {\n\t\tcase job := <-jobQueue:\n\t\t\tjobsMutex.Lock()\n\t\t\tjob.Status = \"processing\"\n\t\t\tjobsMutex.Unlock()\n\t\t\tlog.Printf(\"Worker %d processing job %d\\n\", id, job.ID)\n\t\t\ttime.Sleep(job.Delay) // simulate work\n\t\t\tjobsMutex.Lock()\n\t\t\tjob.Status = \"completed\"\n\t\t\tjob.Result = fmt.Sprintf(\"Job %d done by worker %d\", job.ID, id)\n\t\t\tjobsMutex.Unlock()\n\t\tcase <-ctx.Done():\n\t\t\tlog.Printf(\"Worker %d shutting down\\n\", id)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// addJobHandler adds a new job to the queue\nfunc addJobHandler(w http.ResponseWriter, r *http.Request) {\n\tjobsMutex.Lock()\n\tdefer jobsMutex.Unlock()\n\tjobCounter++\n\tjobID := jobCounter\n\tdelay := time.Duration(rand.Intn(3000)) * time.Millisecond\n\tjob := &Job{\n\t\tID:     jobID,\n\t\tStatus: \"queued\",\n\t\tDelay:  delay,\n\t}\n\tjobs[jobID] = job\n\tjobQueue <- job\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(job)\n}\n\n// getJobsHandler returns all jobs with their status\nfunc getJobsHandler(w http.ResponseWriter, r *http.Request) {\n\tjobsMutex.Lock()\n\tdefer jobsMutex.Unlock()\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjobList := make([]*Job, 0, len(jobs))\n\tfor _, job := range jobs {\n\t\tjobList = append(jobList, job)\n\t}\n\tjson.NewEncoder(w).Encode(jobList)\n}\n\nfunc main() {\n\trand.Seed(time.Now().UnixNano())\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\t// Start a pool of workers\n\tvar wg sync.WaitGroup\n\tnumWorkers := 5\n\tfor i := 1; i <= numWorkers; i++ {\n\t\twg.Add(1)\n\t\tgo worker(ctx, i, &wg)\n\t}\n\n\thttp.HandleFunc(\"/addjob\", addJobHandler)\n\thttp.HandleFunc(\"/jobs\", getJobsHandler)\n\n\tserver := &http.Server{\n\t\tAddr: \":8080\",\n\t}\n\n\t// Run the HTTP server in a separate goroutine\n\tgo func() {\n\t\tlog.Println(\"Starting server on :8080\")\n\t\tif err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\t\tlog.Fatalf(\"Server error: %v\", err)\n\t\t}\n\t}()\n\n\t// For demonstration, shutdown the server after 30 seconds\n\tstop := make(chan struct{})\n\tgo func() {\n\t\ttime.Sleep(30 * time.Second)\n\t\tclose(stop)\n\t}()\n\n\t<-stop\n\tlog.Println(\"Shutting down server...\")\n\tserver.Shutdown(context.Background())\n\tcancel()\n\twg.Wait()\n\tlog.Println(\"Server stopped.\")\n}\n"
  }
}